// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/squat/terraform-provider-saladcloud/internal/sdk/pkg/models/shared"
	"time"
)

func (r *ContainerGroupResourceModel) ToCreateSDKType() *shared.CreateContainerGroup {
	autostartPolicy := r.AutostartPolicy.ValueBool()
	var command []string = nil
	for _, commandItem := range r.Container.Command {
		command = append(command, commandItem.ValueString())
	}
	environmentVariables := make(map[string]string)
	for environmentVariablesKey, environmentVariablesValue := range r.Container.EnvironmentVariables {
		environmentVariablesInst := environmentVariablesValue.ValueString()
		environmentVariables[environmentVariablesKey] = environmentVariablesInst
	}
	image := r.Container.Image.ValueString()
	var logging *shared.CreateContainerLogging
	if r.Container.Logging != nil {
		var newRelic *shared.CreateContainerNewRelic
		if r.Container.Logging.NewRelic != nil {
			host := r.Container.Logging.NewRelic.Host.ValueString()
			ingestionKey := r.Container.Logging.NewRelic.IngestionKey.ValueString()
			newRelic = &shared.CreateContainerNewRelic{
				Host:         host,
				IngestionKey: ingestionKey,
			}
		}
		var splunk *shared.CreateContainerSplunk
		if r.Container.Logging.Splunk != nil {
			host1 := r.Container.Logging.Splunk.Host.ValueString()
			token := r.Container.Logging.Splunk.Token.ValueString()
			splunk = &shared.CreateContainerSplunk{
				Host:  host1,
				Token: token,
			}
		}
		var tcp *shared.CreateContainerTCP
		if r.Container.Logging.TCP != nil {
			host2 := r.Container.Logging.TCP.Host.ValueString()
			port := r.Container.Logging.TCP.Port.ValueInt64()
			tcp = &shared.CreateContainerTCP{
				Host: host2,
				Port: port,
			}
		}
		logging = &shared.CreateContainerLogging{
			NewRelic: newRelic,
			Splunk:   splunk,
			TCP:      tcp,
		}
	}
	var registryAuthentication *shared.RegistryAuthentication
	if r.Container.RegistryAuthentication != nil {
		var awsEcr *shared.AwsEcr
		if r.Container.RegistryAuthentication.AwsEcr != nil {
			accessKeyID := r.Container.RegistryAuthentication.AwsEcr.AccessKeyID.ValueString()
			secretAccessKey := r.Container.RegistryAuthentication.AwsEcr.SecretAccessKey.ValueString()
			awsEcr = &shared.AwsEcr{
				AccessKeyID:     accessKeyID,
				SecretAccessKey: secretAccessKey,
			}
		}
		var basic *shared.Basic
		if r.Container.RegistryAuthentication.Basic != nil {
			password := r.Container.RegistryAuthentication.Basic.Password.ValueString()
			username := r.Container.RegistryAuthentication.Basic.Username.ValueString()
			basic = &shared.Basic{
				Password: password,
				Username: username,
			}
		}
		var dockerHub *shared.DockerHub
		if r.Container.RegistryAuthentication.DockerHub != nil {
			personalAccessToken := r.Container.RegistryAuthentication.DockerHub.PersonalAccessToken.ValueString()
			username1 := r.Container.RegistryAuthentication.DockerHub.Username.ValueString()
			dockerHub = &shared.DockerHub{
				PersonalAccessToken: personalAccessToken,
				Username:            username1,
			}
		}
		var gcpGcr *shared.GcpGcr
		if r.Container.RegistryAuthentication.GcpGcr != nil {
			serviceKey := r.Container.RegistryAuthentication.GcpGcr.ServiceKey.ValueString()
			gcpGcr = &shared.GcpGcr{
				ServiceKey: serviceKey,
			}
		}
		registryAuthentication = &shared.RegistryAuthentication{
			AwsEcr:    awsEcr,
			Basic:     basic,
			DockerHub: dockerHub,
			GcpGcr:    gcpGcr,
		}
	}
	cpu := r.Container.Resources.CPU.ValueInt64()
	gpuClass := new(string)
	if !r.Container.Resources.GpuClass.IsUnknown() && !r.Container.Resources.GpuClass.IsNull() {
		*gpuClass = r.Container.Resources.GpuClass.ValueString()
	} else {
		gpuClass = nil
	}
	var gpuClasses []string = nil
	for _, gpuClassesItem := range r.Container.Resources.GpuClasses {
		gpuClasses = append(gpuClasses, gpuClassesItem.ValueString())
	}
	memory := r.Container.Resources.Memory.ValueInt64()
	resources := shared.ContainerResourceRequirements{
		CPU:        cpu,
		GpuClass:   gpuClass,
		GpuClasses: gpuClasses,
		Memory:     memory,
	}
	container := shared.CreateContainer{
		Command:                command,
		EnvironmentVariables:   environmentVariables,
		Image:                  image,
		Logging:                logging,
		RegistryAuthentication: registryAuthentication,
		Resources:              resources,
	}
	var countryCodes []shared.CountryCode = nil
	for _, countryCodesItem := range r.CountryCodes {
		countryCodes = append(countryCodes, shared.CountryCode(countryCodesItem.ValueString()))
	}
	displayName := new(string)
	if !r.DisplayName.IsUnknown() && !r.DisplayName.IsNull() {
		*displayName = r.DisplayName.ValueString()
	} else {
		displayName = nil
	}
	var livenessProbe *shared.ContainerGroupProbe
	if r.LivenessProbe != nil {
		var exec *shared.ContainerGroupProbeExec
		if r.LivenessProbe.Exec != nil {
			var command1 []string = nil
			for _, commandItem1 := range r.LivenessProbe.Exec.Command {
				command1 = append(command1, commandItem1.ValueString())
			}
			exec = &shared.ContainerGroupProbeExec{
				Command: command1,
			}
		}
		failureThreshold := r.LivenessProbe.FailureThreshold.ValueInt64()
		var grpc *shared.ContainerGroupProbeGrpc
		if r.LivenessProbe.Grpc != nil {
			port1 := r.LivenessProbe.Grpc.Port.ValueInt64()
			service := r.LivenessProbe.Grpc.Service.ValueString()
			grpc = &shared.ContainerGroupProbeGrpc{
				Port:    port1,
				Service: service,
			}
		}
		var http *shared.ContainerGroupProbeHTTP
		if r.LivenessProbe.HTTP != nil {
			var headers []shared.HTTPHeaders = nil
			for _, headersItem := range r.LivenessProbe.HTTP.Headers {
				name := headersItem.Name.ValueString()
				value := headersItem.Value.ValueString()
				headers = append(headers, shared.HTTPHeaders{
					Name:  name,
					Value: value,
				})
			}
			path := r.LivenessProbe.HTTP.Path.ValueString()
			port2 := r.LivenessProbe.HTTP.Port.ValueInt64()
			scheme := new(shared.ContainerProbeHTTPScheme)
			if !r.LivenessProbe.HTTP.Scheme.IsUnknown() && !r.LivenessProbe.HTTP.Scheme.IsNull() {
				*scheme = shared.ContainerProbeHTTPScheme(r.LivenessProbe.HTTP.Scheme.ValueString())
			} else {
				scheme = nil
			}
			http = &shared.ContainerGroupProbeHTTP{
				Headers: headers,
				Path:    path,
				Port:    port2,
				Scheme:  scheme,
			}
		}
		initialDelaySeconds := r.LivenessProbe.InitialDelaySeconds.ValueInt64()
		periodSeconds := r.LivenessProbe.PeriodSeconds.ValueInt64()
		successThreshold := r.LivenessProbe.SuccessThreshold.ValueInt64()
		var tcp1 *shared.ContainerGroupProbeTCP
		if r.LivenessProbe.TCP != nil {
			port3 := r.LivenessProbe.TCP.Port.ValueInt64()
			tcp1 = &shared.ContainerGroupProbeTCP{
				Port: port3,
			}
		}
		timeoutSeconds := r.LivenessProbe.TimeoutSeconds.ValueInt64()
		livenessProbe = &shared.ContainerGroupProbe{
			Exec:                exec,
			FailureThreshold:    failureThreshold,
			Grpc:                grpc,
			HTTP:                http,
			InitialDelaySeconds: initialDelaySeconds,
			PeriodSeconds:       periodSeconds,
			SuccessThreshold:    successThreshold,
			TCP:                 tcp1,
			TimeoutSeconds:      timeoutSeconds,
		}
	}
	name1 := r.Name.ValueString()
	var networking *shared.CreateContainerGroupNetworking
	if r.Networking != nil {
		auth := r.Networking.Auth.ValueBool()
		port4 := r.Networking.Port.ValueInt64()
		protocol := shared.ContainerNetworkingProtocol(r.Networking.Protocol.ValueString())
		networking = &shared.CreateContainerGroupNetworking{
			Auth:     auth,
			Port:     port4,
			Protocol: protocol,
		}
	}
	var readinessProbe *shared.ContainerGroupProbe
	if r.ReadinessProbe != nil {
		var exec1 *shared.ContainerGroupProbeExec
		if r.ReadinessProbe.Exec != nil {
			var command2 []string = nil
			for _, commandItem2 := range r.ReadinessProbe.Exec.Command {
				command2 = append(command2, commandItem2.ValueString())
			}
			exec1 = &shared.ContainerGroupProbeExec{
				Command: command2,
			}
		}
		failureThreshold1 := r.ReadinessProbe.FailureThreshold.ValueInt64()
		var grpc1 *shared.ContainerGroupProbeGrpc
		if r.ReadinessProbe.Grpc != nil {
			port5 := r.ReadinessProbe.Grpc.Port.ValueInt64()
			service1 := r.ReadinessProbe.Grpc.Service.ValueString()
			grpc1 = &shared.ContainerGroupProbeGrpc{
				Port:    port5,
				Service: service1,
			}
		}
		var http1 *shared.ContainerGroupProbeHTTP
		if r.ReadinessProbe.HTTP != nil {
			var headers1 []shared.HTTPHeaders = nil
			for _, headersItem1 := range r.ReadinessProbe.HTTP.Headers {
				name2 := headersItem1.Name.ValueString()
				value1 := headersItem1.Value.ValueString()
				headers1 = append(headers1, shared.HTTPHeaders{
					Name:  name2,
					Value: value1,
				})
			}
			path1 := r.ReadinessProbe.HTTP.Path.ValueString()
			port6 := r.ReadinessProbe.HTTP.Port.ValueInt64()
			scheme1 := new(shared.ContainerProbeHTTPScheme)
			if !r.ReadinessProbe.HTTP.Scheme.IsUnknown() && !r.ReadinessProbe.HTTP.Scheme.IsNull() {
				*scheme1 = shared.ContainerProbeHTTPScheme(r.ReadinessProbe.HTTP.Scheme.ValueString())
			} else {
				scheme1 = nil
			}
			http1 = &shared.ContainerGroupProbeHTTP{
				Headers: headers1,
				Path:    path1,
				Port:    port6,
				Scheme:  scheme1,
			}
		}
		initialDelaySeconds1 := r.ReadinessProbe.InitialDelaySeconds.ValueInt64()
		periodSeconds1 := r.ReadinessProbe.PeriodSeconds.ValueInt64()
		successThreshold1 := r.ReadinessProbe.SuccessThreshold.ValueInt64()
		var tcp2 *shared.ContainerGroupProbeTCP
		if r.ReadinessProbe.TCP != nil {
			port7 := r.ReadinessProbe.TCP.Port.ValueInt64()
			tcp2 = &shared.ContainerGroupProbeTCP{
				Port: port7,
			}
		}
		timeoutSeconds1 := r.ReadinessProbe.TimeoutSeconds.ValueInt64()
		readinessProbe = &shared.ContainerGroupProbe{
			Exec:                exec1,
			FailureThreshold:    failureThreshold1,
			Grpc:                grpc1,
			HTTP:                http1,
			InitialDelaySeconds: initialDelaySeconds1,
			PeriodSeconds:       periodSeconds1,
			SuccessThreshold:    successThreshold1,
			TCP:                 tcp2,
			TimeoutSeconds:      timeoutSeconds1,
		}
	}
	replicas := r.Replicas.ValueInt64()
	restartPolicy := shared.ContainerRestartPolicy(r.RestartPolicy.ValueString())
	var startupProbe *shared.ContainerGroupProbe
	if r.StartupProbe != nil {
		var exec2 *shared.ContainerGroupProbeExec
		if r.StartupProbe.Exec != nil {
			var command3 []string = nil
			for _, commandItem3 := range r.StartupProbe.Exec.Command {
				command3 = append(command3, commandItem3.ValueString())
			}
			exec2 = &shared.ContainerGroupProbeExec{
				Command: command3,
			}
		}
		failureThreshold2 := r.StartupProbe.FailureThreshold.ValueInt64()
		var grpc2 *shared.ContainerGroupProbeGrpc
		if r.StartupProbe.Grpc != nil {
			port8 := r.StartupProbe.Grpc.Port.ValueInt64()
			service2 := r.StartupProbe.Grpc.Service.ValueString()
			grpc2 = &shared.ContainerGroupProbeGrpc{
				Port:    port8,
				Service: service2,
			}
		}
		var http2 *shared.ContainerGroupProbeHTTP
		if r.StartupProbe.HTTP != nil {
			var headers2 []shared.HTTPHeaders = nil
			for _, headersItem2 := range r.StartupProbe.HTTP.Headers {
				name3 := headersItem2.Name.ValueString()
				value2 := headersItem2.Value.ValueString()
				headers2 = append(headers2, shared.HTTPHeaders{
					Name:  name3,
					Value: value2,
				})
			}
			path2 := r.StartupProbe.HTTP.Path.ValueString()
			port9 := r.StartupProbe.HTTP.Port.ValueInt64()
			scheme2 := new(shared.ContainerProbeHTTPScheme)
			if !r.StartupProbe.HTTP.Scheme.IsUnknown() && !r.StartupProbe.HTTP.Scheme.IsNull() {
				*scheme2 = shared.ContainerProbeHTTPScheme(r.StartupProbe.HTTP.Scheme.ValueString())
			} else {
				scheme2 = nil
			}
			http2 = &shared.ContainerGroupProbeHTTP{
				Headers: headers2,
				Path:    path2,
				Port:    port9,
				Scheme:  scheme2,
			}
		}
		initialDelaySeconds2 := r.StartupProbe.InitialDelaySeconds.ValueInt64()
		periodSeconds2 := r.StartupProbe.PeriodSeconds.ValueInt64()
		successThreshold2 := r.StartupProbe.SuccessThreshold.ValueInt64()
		var tcp3 *shared.ContainerGroupProbeTCP
		if r.StartupProbe.TCP != nil {
			port10 := r.StartupProbe.TCP.Port.ValueInt64()
			tcp3 = &shared.ContainerGroupProbeTCP{
				Port: port10,
			}
		}
		timeoutSeconds2 := r.StartupProbe.TimeoutSeconds.ValueInt64()
		startupProbe = &shared.ContainerGroupProbe{
			Exec:                exec2,
			FailureThreshold:    failureThreshold2,
			Grpc:                grpc2,
			HTTP:                http2,
			InitialDelaySeconds: initialDelaySeconds2,
			PeriodSeconds:       periodSeconds2,
			SuccessThreshold:    successThreshold2,
			TCP:                 tcp3,
			TimeoutSeconds:      timeoutSeconds2,
		}
	}
	out := shared.CreateContainerGroup{
		AutostartPolicy: autostartPolicy,
		Container:       container,
		CountryCodes:    countryCodes,
		DisplayName:     displayName,
		LivenessProbe:   livenessProbe,
		Name:            name1,
		Networking:      networking,
		ReadinessProbe:  readinessProbe,
		Replicas:        replicas,
		RestartPolicy:   restartPolicy,
		StartupProbe:    startupProbe,
	}
	return &out
}

func (r *ContainerGroupResourceModel) ToGetSDKType() *shared.CreateContainerGroup {
	out := r.ToCreateSDKType()
	return out
}

func (r *ContainerGroupResourceModel) ToUpdateSDKType() *shared.UpdateContainerGroup {
	displayName := new(string)
	if !r.DisplayName.IsUnknown() && !r.DisplayName.IsNull() {
		*displayName = r.DisplayName.ValueString()
	} else {
		displayName = nil
	}
	replicas := new(int64)
	if !r.Replicas.IsUnknown() && !r.Replicas.IsNull() {
		*replicas = r.Replicas.ValueInt64()
	} else {
		replicas = nil
	}
	out := shared.UpdateContainerGroup{
		DisplayName: displayName,
		Replicas:    replicas,
	}
	return &out
}

func (r *ContainerGroupResourceModel) ToDeleteSDKType() *shared.CreateContainerGroup {
	out := r.ToCreateSDKType()
	return out
}

func (r *ContainerGroupResourceModel) RefreshFromGetResponse(resp *shared.ContainerGroup) {
	r.AutostartPolicy = types.BoolValue(resp.AutostartPolicy)
	r.Container.Command = nil
	for _, v := range resp.Container.Command {
		r.Container.Command = append(r.Container.Command, types.StringValue(v))
	}
	if r.Container.EnvironmentVariables == nil && len(resp.Container.EnvironmentVariables) > 0 {
		r.Container.EnvironmentVariables = make(map[string]types.String)
		for key, value := range resp.Container.EnvironmentVariables {
			r.Container.EnvironmentVariables[key] = types.StringValue(value)
		}
	}
	r.Container.Image = types.StringValue(resp.Container.Image)
	if resp.Container.Logging == nil {
		r.Container.Logging = nil
	} else {
		r.Container.Logging = &Logging{}
		if resp.Container.Logging.NewRelic == nil {
			r.Container.Logging.NewRelic = nil
		} else {
			r.Container.Logging.NewRelic = &NewRelic{}
			r.Container.Logging.NewRelic.Host = types.StringValue(resp.Container.Logging.NewRelic.Host)
			r.Container.Logging.NewRelic.IngestionKey = types.StringValue(resp.Container.Logging.NewRelic.IngestionKey)
		}
		if resp.Container.Logging.Splunk == nil {
			r.Container.Logging.Splunk = nil
		} else {
			r.Container.Logging.Splunk = &Splunk{}
			r.Container.Logging.Splunk.Host = types.StringValue(resp.Container.Logging.Splunk.Host)
			r.Container.Logging.Splunk.Token = types.StringValue(resp.Container.Logging.Splunk.Token)
		}
		if resp.Container.Logging.TCP == nil {
			r.Container.Logging.TCP = nil
		} else {
			r.Container.Logging.TCP = &TCP{}
			r.Container.Logging.TCP.Host = types.StringValue(resp.Container.Logging.TCP.Host)
			r.Container.Logging.TCP.Port = types.Int64Value(resp.Container.Logging.TCP.Port)
		}
	}
	r.Container.Resources.CPU = types.Int64Value(resp.Container.Resources.CPU)
	if resp.Container.Resources.GpuClass != nil {
		r.Container.Resources.GpuClass = types.StringValue(*resp.Container.Resources.GpuClass)
	} else {
		r.Container.Resources.GpuClass = types.StringNull()
	}
	r.Container.Resources.GpuClasses = nil
	for _, v := range resp.Container.Resources.GpuClasses {
		r.Container.Resources.GpuClasses = append(r.Container.Resources.GpuClasses, types.StringValue(v))
	}
	r.Container.Resources.Memory = types.Int64Value(resp.Container.Resources.Memory)
	r.CountryCodes = nil
	for _, v := range resp.CountryCodes {
		r.CountryCodes = append(r.CountryCodes, types.StringValue(string(v)))
	}
	r.CreateTime = types.StringValue(resp.CreateTime.Format(time.RFC3339Nano))
	if resp.CurrentState.Description != nil {
		r.CurrentState.Description = types.StringValue(*resp.CurrentState.Description)
	} else {
		r.CurrentState.Description = types.StringNull()
	}
	r.CurrentState.FinishTime = types.StringValue(resp.CurrentState.FinishTime.Format(time.RFC3339Nano))
	r.CurrentState.InstanceStatusCount.AllocatingCount = types.Int64Value(resp.CurrentState.InstanceStatusCount.AllocatingCount)
	r.CurrentState.InstanceStatusCount.CreatingCount = types.Int64Value(resp.CurrentState.InstanceStatusCount.CreatingCount)
	r.CurrentState.InstanceStatusCount.RunningCount = types.Int64Value(resp.CurrentState.InstanceStatusCount.RunningCount)
	r.CurrentState.StartTime = types.StringValue(resp.CurrentState.StartTime.Format(time.RFC3339Nano))
	r.CurrentState.Status = types.StringValue(string(resp.CurrentState.Status))
	r.DisplayName = types.StringValue(resp.DisplayName)
	r.ID = types.StringValue(resp.ID)
	if resp.LivenessProbe == nil {
		r.LivenessProbe = nil
	} else {
		r.LivenessProbe = &ContainerGroupProbe{}
		if resp.LivenessProbe.Exec == nil {
			r.LivenessProbe.Exec = nil
		} else {
			r.LivenessProbe.Exec = &ContainerGroupProbeExec{}
			r.LivenessProbe.Exec.Command = nil
			for _, v := range resp.LivenessProbe.Exec.Command {
				r.LivenessProbe.Exec.Command = append(r.LivenessProbe.Exec.Command, types.StringValue(v))
			}
		}
		r.LivenessProbe.FailureThreshold = types.Int64Value(resp.LivenessProbe.FailureThreshold)
		if resp.LivenessProbe.Grpc == nil {
			r.LivenessProbe.Grpc = nil
		} else {
			r.LivenessProbe.Grpc = &ContainerGroupProbeGrpc{}
			r.LivenessProbe.Grpc.Port = types.Int64Value(resp.LivenessProbe.Grpc.Port)
			r.LivenessProbe.Grpc.Service = types.StringValue(resp.LivenessProbe.Grpc.Service)
		}
		if resp.LivenessProbe.HTTP == nil {
			r.LivenessProbe.HTTP = nil
		} else {
			r.LivenessProbe.HTTP = &ContainerGroupProbeHTTP{}
			r.LivenessProbe.HTTP.Headers = nil
			for _, headersItem := range resp.LivenessProbe.HTTP.Headers {
				var headers1 HTTPHeaders
				headers1.Name = types.StringValue(headersItem.Name)
				headers1.Value = types.StringValue(headersItem.Value)
				r.LivenessProbe.HTTP.Headers = append(r.LivenessProbe.HTTP.Headers, headers1)
			}
			r.LivenessProbe.HTTP.Path = types.StringValue(resp.LivenessProbe.HTTP.Path)
			r.LivenessProbe.HTTP.Port = types.Int64Value(resp.LivenessProbe.HTTP.Port)
			if resp.LivenessProbe.HTTP.Scheme != nil {
				r.LivenessProbe.HTTP.Scheme = types.StringValue(string(*resp.LivenessProbe.HTTP.Scheme))
			} else {
				r.LivenessProbe.HTTP.Scheme = types.StringNull()
			}
		}
		r.LivenessProbe.InitialDelaySeconds = types.Int64Value(resp.LivenessProbe.InitialDelaySeconds)
		r.LivenessProbe.PeriodSeconds = types.Int64Value(resp.LivenessProbe.PeriodSeconds)
		r.LivenessProbe.SuccessThreshold = types.Int64Value(resp.LivenessProbe.SuccessThreshold)
		if resp.LivenessProbe.TCP == nil {
			r.LivenessProbe.TCP = nil
		} else {
			r.LivenessProbe.TCP = &ContainerGroupProbeTCP{}
			r.LivenessProbe.TCP.Port = types.Int64Value(resp.LivenessProbe.TCP.Port)
		}
		r.LivenessProbe.TimeoutSeconds = types.Int64Value(resp.LivenessProbe.TimeoutSeconds)
	}
	r.Name = types.StringValue(resp.Name)
	if resp.Networking == nil {
		r.Networking = nil
	} else {
		r.Networking = &ContainerGroupNetworking{}
		r.Networking.Auth = types.BoolValue(resp.Networking.Auth)
		r.Networking.DNS = types.StringValue(resp.Networking.DNS)
		r.Networking.Port = types.Int64Value(resp.Networking.Port)
		r.Networking.Protocol = types.StringValue(string(resp.Networking.Protocol))
	}
	if resp.ReadinessProbe == nil {
		r.ReadinessProbe = nil
	} else {
		r.ReadinessProbe = &ContainerGroupProbe{}
		if resp.ReadinessProbe.Exec == nil {
			r.ReadinessProbe.Exec = nil
		} else {
			r.ReadinessProbe.Exec = &ContainerGroupProbeExec{}
			r.ReadinessProbe.Exec.Command = nil
			for _, v := range resp.ReadinessProbe.Exec.Command {
				r.ReadinessProbe.Exec.Command = append(r.ReadinessProbe.Exec.Command, types.StringValue(v))
			}
		}
		r.ReadinessProbe.FailureThreshold = types.Int64Value(resp.ReadinessProbe.FailureThreshold)
		if resp.ReadinessProbe.Grpc == nil {
			r.ReadinessProbe.Grpc = nil
		} else {
			r.ReadinessProbe.Grpc = &ContainerGroupProbeGrpc{}
			r.ReadinessProbe.Grpc.Port = types.Int64Value(resp.ReadinessProbe.Grpc.Port)
			r.ReadinessProbe.Grpc.Service = types.StringValue(resp.ReadinessProbe.Grpc.Service)
		}
		if resp.ReadinessProbe.HTTP == nil {
			r.ReadinessProbe.HTTP = nil
		} else {
			r.ReadinessProbe.HTTP = &ContainerGroupProbeHTTP{}
			r.ReadinessProbe.HTTP.Headers = nil
			for _, headersItem1 := range resp.ReadinessProbe.HTTP.Headers {
				var headers3 HTTPHeaders
				headers3.Name = types.StringValue(headersItem1.Name)
				headers3.Value = types.StringValue(headersItem1.Value)
				r.ReadinessProbe.HTTP.Headers = append(r.ReadinessProbe.HTTP.Headers, headers3)
			}
			r.ReadinessProbe.HTTP.Path = types.StringValue(resp.ReadinessProbe.HTTP.Path)
			r.ReadinessProbe.HTTP.Port = types.Int64Value(resp.ReadinessProbe.HTTP.Port)
			if resp.ReadinessProbe.HTTP.Scheme != nil {
				r.ReadinessProbe.HTTP.Scheme = types.StringValue(string(*resp.ReadinessProbe.HTTP.Scheme))
			} else {
				r.ReadinessProbe.HTTP.Scheme = types.StringNull()
			}
		}
		r.ReadinessProbe.InitialDelaySeconds = types.Int64Value(resp.ReadinessProbe.InitialDelaySeconds)
		r.ReadinessProbe.PeriodSeconds = types.Int64Value(resp.ReadinessProbe.PeriodSeconds)
		r.ReadinessProbe.SuccessThreshold = types.Int64Value(resp.ReadinessProbe.SuccessThreshold)
		if resp.ReadinessProbe.TCP == nil {
			r.ReadinessProbe.TCP = nil
		} else {
			r.ReadinessProbe.TCP = &ContainerGroupProbeTCP{}
			r.ReadinessProbe.TCP.Port = types.Int64Value(resp.ReadinessProbe.TCP.Port)
		}
		r.ReadinessProbe.TimeoutSeconds = types.Int64Value(resp.ReadinessProbe.TimeoutSeconds)
	}
	r.Replicas = types.Int64Value(resp.Replicas)
	r.RestartPolicy = types.StringValue(string(resp.RestartPolicy))
	if resp.StartupProbe == nil {
		r.StartupProbe = nil
	} else {
		r.StartupProbe = &ContainerGroupProbe{}
		if resp.StartupProbe.Exec == nil {
			r.StartupProbe.Exec = nil
		} else {
			r.StartupProbe.Exec = &ContainerGroupProbeExec{}
			r.StartupProbe.Exec.Command = nil
			for _, v := range resp.StartupProbe.Exec.Command {
				r.StartupProbe.Exec.Command = append(r.StartupProbe.Exec.Command, types.StringValue(v))
			}
		}
		r.StartupProbe.FailureThreshold = types.Int64Value(resp.StartupProbe.FailureThreshold)
		if resp.StartupProbe.Grpc == nil {
			r.StartupProbe.Grpc = nil
		} else {
			r.StartupProbe.Grpc = &ContainerGroupProbeGrpc{}
			r.StartupProbe.Grpc.Port = types.Int64Value(resp.StartupProbe.Grpc.Port)
			r.StartupProbe.Grpc.Service = types.StringValue(resp.StartupProbe.Grpc.Service)
		}
		if resp.StartupProbe.HTTP == nil {
			r.StartupProbe.HTTP = nil
		} else {
			r.StartupProbe.HTTP = &ContainerGroupProbeHTTP{}
			r.StartupProbe.HTTP.Headers = nil
			for _, headersItem2 := range resp.StartupProbe.HTTP.Headers {
				var headers5 HTTPHeaders
				headers5.Name = types.StringValue(headersItem2.Name)
				headers5.Value = types.StringValue(headersItem2.Value)
				r.StartupProbe.HTTP.Headers = append(r.StartupProbe.HTTP.Headers, headers5)
			}
			r.StartupProbe.HTTP.Path = types.StringValue(resp.StartupProbe.HTTP.Path)
			r.StartupProbe.HTTP.Port = types.Int64Value(resp.StartupProbe.HTTP.Port)
			if resp.StartupProbe.HTTP.Scheme != nil {
				r.StartupProbe.HTTP.Scheme = types.StringValue(string(*resp.StartupProbe.HTTP.Scheme))
			} else {
				r.StartupProbe.HTTP.Scheme = types.StringNull()
			}
		}
		r.StartupProbe.InitialDelaySeconds = types.Int64Value(resp.StartupProbe.InitialDelaySeconds)
		r.StartupProbe.PeriodSeconds = types.Int64Value(resp.StartupProbe.PeriodSeconds)
		r.StartupProbe.SuccessThreshold = types.Int64Value(resp.StartupProbe.SuccessThreshold)
		if resp.StartupProbe.TCP == nil {
			r.StartupProbe.TCP = nil
		} else {
			r.StartupProbe.TCP = &ContainerGroupProbeTCP{}
			r.StartupProbe.TCP.Port = types.Int64Value(resp.StartupProbe.TCP.Port)
		}
		r.StartupProbe.TimeoutSeconds = types.Int64Value(resp.StartupProbe.TimeoutSeconds)
	}
	r.UpdateTime = types.StringValue(resp.UpdateTime.Format(time.RFC3339Nano))
}

func (r *ContainerGroupResourceModel) RefreshFromCreateResponse(resp *shared.ContainerGroup) {
	r.RefreshFromGetResponse(resp)
}

func (r *ContainerGroupResourceModel) RefreshFromUpdateResponse(resp *shared.ContainerGroup) {
	r.RefreshFromGetResponse(resp)
}
